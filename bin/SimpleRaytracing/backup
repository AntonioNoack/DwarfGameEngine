package SimpleRaytracing;

import DwarfEngine.Engine;
import DwarfEngine.MathTypes.Mathf;
import DwarfEngine.MathTypes.Vector2;
import DwarfEngine.MathTypes.Vector3;

public class Raycaster {
	private static float[] solveQuadratic(float a, float b, float c) {
		float discriminant = b*b-4*a*c;
		
		float[] solutions;
		if (discriminant > 0) {
			solutions = new float[2];
			float sqrtDiscr = (float) Math.sqrt(discriminant);
			solutions[0] = (-b - sqrtDiscr)/(2*a);
			solutions[1] = (-b + sqrtDiscr)/(2*a);
		}
		else if(discriminant == 0) {
			solutions = new float[1];
			solutions[0] = -b/(2*a);
		}
		else {
			solutions = null;
		}
		return solutions;
	}
	
	private static float[] evaluateQuadraticFormula(float coef1, float coef2) {
		float[] quadratic = new float[3];
		quadratic[0] = coef1*coef1;
		quadratic[1] = 2*coef1*coef2;
		quadratic[2] = coef2*coef2;
		return quadratic;
	}
	private static float[] addQuadraticFormulas(float[] quadratic1, float[] quadratic2) {
		float[] sum = new float[3];
		sum[0] = quadratic1[0]+quadratic2[0];
		sum[1] = quadratic1[1]+quadratic2[1];
		sum[2] = quadratic1[2]+quadratic2[2];
		return sum;
	}
	
	public static boolean Raycast(RaycastHit hit, Vector2 origin, Vector2 direction, Vector2 center, float radius) {
		if (hit == null) return false;
		
		float[] quadratic1 = evaluateQuadraticFormula(direction.x, origin.x-center.x);
		float[] quadratic2 = evaluateQuadraticFormula(direction.y, origin.y-center.y);
		float[] finalQuadratic = addQuadraticFormulas(quadratic1, quadratic2);
		
		float[] hitPoints = solveQuadratic(finalQuadratic[0], finalQuadratic[1], finalQuadratic[2]-(radius*radius));
		if (hitPoints == null) {
			return false;
		}
		Vector2 hitPoint = null;
		
		for (float f : hitPoints) {
			float angle = Mathf.atan(direction.y/direction.x);
			Vector2 p =  Vector2.add(origin, Vector2.multiply(direction, f));
			if ((Mathf.cos(angle)*p.x) > origin.x*Mathf.cos(angle)) {
				hitPoint = p;
				break;
			}
		}
		
		if (hitPoint != null) {
			hit.point = new Vector3(hitPoint.x, hitPoint.y, 0);
			return true;
		}
		return false;
	}
}
